public struct Response: Identifiable, Codable, Equatable, Sendable {
	public struct StatusDetails: Codable, Equatable, Sendable {
		public struct ErrorInfo: Codable, Equatable, Sendable {
			public let code: String?
			public let type: String?
			public let message: String?
		}

		/// Populated when the response fails.
		public let error: ErrorInfo?
		/// Reason for cancelled/incomplete responses.
		public let reason: String?
		/// Mirrors the status category (completed, cancelled, incomplete, failed).
		public let type: String?
	}

	public struct Config: Codable, Equatable, Sendable {
		public enum Conversation: String, Codable, Equatable, Sendable {
			/// The contents of the response will be added to the default conversation.
			case auto
			/// An out-of-band response which will not add items to default conversation.
			case none
		}

		/// The modalities for the response.
		public let modalities: [Session.Modality]
		/// Instructions for the model.
		public let instructions: String
		/// The voice the model uses to respond.
		public let voice: Session.Voice
		/// The format of output audio.
		public let outputAudioFormat: Session.AudioFormat
		/// Tools (functions) available to the model.
		public let tools: [Session.Tool]
		/// How the model chooses tools.
		public let toolChoice: Session.ToolChoice
		/// Sampling temperature.
		public let temperature: Double
		/// Maximum number of output tokens.
		public let maxResponseOutputTokens: Int?
		/// Controls which conversation the response is added to.
		public let conversation: Conversation?
		/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
		public let metadata: [String: String]?
		/// Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation.
		public let input: [Item]?

		public init(modalities: [Session.Modality] = [.text, .audio], instructions: String, voice: Session.Voice = .alloy, outputAudioFormat: Session.AudioFormat = .pcm16, tools: [Session.Tool] = [], toolChoice: Session.ToolChoice = .auto, temperature: Double = 1, maxResponseOutputTokens: Int? = nil, conversation: Conversation? = .auto, metadata: [String: String]? = nil, input: [Item]? = nil) {
			self.input = input
			self.voice = voice
			self.tools = tools
			self.metadata = metadata
			self.toolChoice = toolChoice
			self.modalities = modalities
			self.temperature = temperature
			self.instructions = instructions
			self.conversation = conversation
			self.outputAudioFormat = outputAudioFormat
			self.maxResponseOutputTokens = maxResponseOutputTokens
		}
	}

	public enum Status: String, Codable, Equatable, Sendable {
		case failed
		case completed
		case cancelled
		case incomplete
		case inProgress = "in_progress"
	}

	public struct Usage: Codable, Equatable, Sendable {
		public let totalTokens: Int
		public let inputTokens: Int
		public let outputTokens: Int
		public let inputTokenDetails: InputTokenDetails
		public let outputTokenDetails: OutputTokenDetails

		public struct InputTokenDetails: Codable, Equatable, Sendable {
			public let textTokens: Int
			public let audioTokens: Int
			public let imageTokens: Int?
			public let cachedTokens: Int
			public let cachedTokensDetails: CachedTokensDetails

			public struct CachedTokensDetails: Codable, Equatable, Sendable {
				public let textTokens: Int
				public let audioTokens: Int
				public let imageTokens: Int?
			}
		}

		public struct OutputTokenDetails: Codable, Equatable, Sendable {
			public let textTokens: Int
			public let audioTokens: Int
		}
	}

	/// Response object type.
	public let object: String?
	/// The unique ID of the response.
	public let id: String
	/// The status of the response.
	public let status: Status
	/// Additional details about the response status.
	public let statusDetails: StatusDetails?
	/// The list of output items generated by the response.
	public let output: [Item]
	/// The conversation the response belongs to.
	public let conversationId: String?
	/// The modalities used for this response.
	public let modalities: [Session.Modality]?
	/// Voice used for the response.
	public let voice: Session.Voice?
	/// Output audio format for the response.
	public let outputAudioFormat: Session.AudioFormat?
	/// Sampling temperature.
	public let temperature: Double?
	/// Maximum number of output tokens.
	public let maxOutputTokens: MaxOutputTokens?
	/// Usage statistics for the response.
	public let usage: Usage?
	/// Developer-provided string key-value pairs associated with this response.
	public let metadata: [String: String]?

	public enum MaxOutputTokens: Codable, Equatable, Sendable {
		case finite(Int)
		case unlimited

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			if let intValue = try? container.decode(Int.self) {
				self = .finite(intValue)
				return
			}
			let stringValue = try container.decode(String.self)
			self = stringValue == "inf" ? .unlimited : .unlimited
		}

		public func encode(to encoder: Encoder) throws {
			var container = encoder.singleValueContainer()
			switch self {
			case let .finite(value):
				try container.encode(value)
			case .unlimited:
				try container.encode("inf")
			}
		}
	}

}
